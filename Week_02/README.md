# 第二周学习总结

### 知识点回顾

本周主要讲解了`散列表`、`树`、`堆`和`图`这几个数据结构和相关的基础算法。

#### 散列表

散列表是对数组的一种扩展升级的数据结构，其实现逻辑是，通过数据生成的`哈希值`映射到一个内存的`下标`中直接返回，因此其访问的时间复杂度是O(1)。其哈希值的生成一般需要一个`哈希函数`，大部分语言比如Java可以自己定义实现哈希函数，哈希函数就是讲数据通过特定的函数生成一个Int类型的值的函数。
散列表存在一个问题就是哈希碰撞，即，不同的一些数据通过哈希函数最终会映射到相同的一个位置。哈希碰撞是基本无法避免的，因此需要特定的方法解决哈希碰撞。常见的解决方法是`链表法`和`开放寻址法`：

* 链表法：对于哈希函数重复的数据对应的值生成一条链表而不是直接的数值，因此相同的数据都会存放在相同的链表中
* 开放寻址法：存在哈希碰撞时，通过对应的实现逻辑比如访问下一个散列地址等将冲突的数据存放在不同的哈希表的位置中

可见，不论是链表法还是开放寻址法，都会存在一定的问题。对于链表法：如果哈希碰撞过多，则散列表会退化成一张链表，时间复杂度会直接下降为O(n)。而开放寻址法，则会存在如果数据量过多则无法解决的问题。

因此，如何解决哈希冲突即是提高哈希表性能的关键，一般好的方法是设计好的哈希函数以及合理的装载因子。（这部分内容在王争老师的专栏 [数据结构与算法之美](https://time.geekbang.org/column/article/64586) 中介绍的比较详细）

关于Java中的HashMap，它不仅仅是一个单纯的散列表，在初始化时其Capacity是8，数据增加时其容量会动态增加。当增加到16以上之后，其会升级成`红黑树`，当数据减少到16以下后，又会变成散列表。设计是为了更好的解决散列冲突，从而避免性能下降。

#### 树

和之前所说的那些数据结构不同，树是一个`二维`的数据结构，其可以看作是有两个或以上的后续指针的链表。
树有一个树根节点Root，其左右后续节点被称为子节点，多个子节点直接称为兄弟节点，并且常常会把没有子节点的节点称为叶子节点。
树还存在`高度`、`深度`和`层级`这三个概念：

* 高度：节点到叶子节点的`最长路径`
* 深度：根节点到一个节点所经历的`边的个数`
* 层级：可以等同于深度，也可以是深度加1

对于以下这么一棵树来说：

```
                        高度        深度        层级
        A                2          0         1（或0）
    B       C            1          1         2（或1）
  D   E   F   G          0          2         3（或2）
```

有两个后续节点的链表就是树，而有环的树就是图。树的发明可以看做是对维度的扩展，日常生活中会出现多个不同路径的这类问题都可以用树来进行模拟。

#### 二叉树

在现实中用到最多的是`二叉树`，二叉树即每个节点最多只有两个子节点的树。 除了最后一层其余所有层都达到左右子节点都存在并且最后一层的所有节点都是先左后右排列的二叉树被称为`完全二叉树`。

树的存储可以通过`链表`和`数组`实现，链表就是最常见的树的存储方式：

``` C#
public class TreeNode {
    private TreeNode left;
    private TreeNode right;
    private int val;

    public TreeNode(TreeNode left, TreeNode right) {
        this.left = left;
        this.right = right;
    }
}
```

通过数组存储的方法就是将树的所有节点`从上到下`、`从左到右`、`依次`存放在一个数组中，其中如果设一个父节点的数组下标是i，那么它的两个子节点的下标即为 `2 * i + 1` 和 `2 * i + 2`，相反地，子节点对应的父节点的下标是 `[(i - 1) / 2]取整`。

树的遍历的一般方法是递归，一个树的遍历会存在三条遍历语句，即：

``` C#
// 伪代码
iterate(node.left); // 遍历左子树
iterate(node);  // 遍历父节点
iterate(node.right);  // 遍历右子树
```

这三条语句的执行顺序一般被归结为三种树的遍历方式，即：

* 前序遍历： 中 --> 左 --> 右
* 中序遍历： 左 --> 中 --> 右
* 前序遍历： 左 --> 右 --> 中

#### 二叉搜索树

普通的一颗树对性能没有什么提升，遍历的时间复杂度也和链表相同，为了让树这种数据结构有意义，一般会人为的对树进行一些限制，比如二叉搜索树（BST)即为：

1. 可以是空树
2. 所有的左子节点的值均小于其父节点
3. 所有的右子节点的值均大于其父节点

在有了这个限制之后，二叉搜索树的性能就被提升了，其查询、插入和删除的时间复杂度都升级为O(logN)，其主要逻辑为：

* 查询：等同于二分查找，每次之后查找左节点或右节点
* 插入/删除：都是从根节点开始查找，插入操作时找到一个可以插入的叶子节点判断值进行插入，删除就是找到值删除，如果删除的值不是叶子节点，则一般会将第一个大于删除节点值的节点替换到对应的删除节点的位置

#### 堆

堆是一个`抽象数据结构`，它可以类比于项目工程中的一个接口，它只给出了一个定义，即：

> 能够在O(1)的时间复杂度内找到其中的最大值`或`最小值

常见的堆都是通过二叉树实现的`二叉堆`，在项目工程中为了更好的时间复杂度，一般会采用菲波那切堆（多叉树）实现一个堆。

二叉堆的时间复杂度为：

* FindMax： O(1)
* DeleteMax：O(logN)
* Insert：O(logN)或O(1)

二叉堆大顶存在以下性质：

1. 是一颗完全二叉树
2. 树中的任意节点的值总是大于或等于其子节点的值

创建一个堆的操作被称为`堆化（Heapify）`：

* Insert：将需要插入的节点先插入到完全二叉树的最后一个位置，然后依次做HeapifyUp操作，即：与父节点比较交换，只到其大于子节点且小于父节点
* Delete：等同于插入操作的反操作HeapifyDown，将需要删除的节点与最后一个节点交换，之后再做替换操作。这里如果碰到左右节点都大于自己的情况，需要将大的那个节点进行交换

特别说明一点：

> 在.Net中没有提供类似于Java中的Priority Queue这样的数据结构来模拟一个堆，一般的堆使用 `SortedSet`这样一个数据结构实现的（查看了SortedSet源码，发现其内部是用红黑树实现），但是其存在一个问题，就是它无法插入相同的元素，因此如果要做LeetCode上有关堆的题目，一般还需要创建一个HashMap进行排重，如：[239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)

#### 图

是一个有`点`和`边`组成的数据结构，其没有过多的约束条件。其中点和边也存在一些概念：

* 点：存在`出度`和`入度`的概念，即这个点指向其他点的边的数量以及其他点指向它的边的数量
* 边：边存在`方向`和`权重`两个概念，方向很好理解，其权重可以理解为`长度`或者`损耗`

根据上述的一切概念，图可以分为`有向/无向`-`有权/无权`图。

图在内存中一般通过`邻接表`和`邻接矩阵`存储。其中：

* 邻接表：即为一个一位数组+链表，其中一维数组的各个下标表示图中的各个点，其value是一个链表，表示这个点与其他点的连接状态
* 邻接矩阵： 即为一个二维数组，其row和column表示各个点，其中`graph[1][2]`可以表示点1到点2的联通状态

图中常用的算法包括：`DFS`、`BFS`、`最短路径`和`拓扑排序`等。